<!-- # a 3D vuemeter in Real Time -->
<!-- This example will show you how to create a 3D vuemetter with Web Audio API. -->
<!-- We use [webaudio.js](https://github.com/jeromeetienne/webaudio.js), a web audio library -->
<!-- for game. It is build on top of Web Audio API.
<!-- I recently did a presentation at [musichackparis](http://www.musichackparis.org) on Web Audio API. -->
<!-- Slides are [here](http://jeromeetienne.github.com/slides/webaudioapi). -->

<!-- ```webaudio.js``` has been first coded as a tQuery plugins, ```tQuery.WebAudio```. -->
<!-- You can find a [post about it](http://learningthreejs.com/blog/2012/03/20/sounds-for-more-realistic-3d/) -->
<!-- on [learningthreejs](http://learningthreejs.com) blog. -->
<!-- But this technology is so nice, it deserved its [own repository](https://github.com/jeromeetienne/webaudio.js). -->
<!-- The library gained in flexibility in the process: It is now possible to display historgram in canvas2D -->
<!-- of simply play sound :) -->

<!-- init the html page -->
<!-- include webaudio.js -->
<!-- include tquery-bundle.js -->
<!-- TODO what is tquery. what is -bundle. url to find it -->
<!doctype html><title>webaudio example: histo3d</title>
<script src="../build/webaudio.js"></script>
<script src="vendor/tquery/tquery-bundle.js"></script>
<body><script>
	// # Let's get started
	
	// First we gonna intenciate ```WebAudio```. This will initialize the layer.
	// It will create the [AudioNode](https://dvcs.w3.org/hg/audio/raw-file/tip/webaudio/specification.html#AudioNode-section)`s
	// for the end of the chain.
	// By default it contains a
	// [gainNode](https://dvcs.w3.org/hg/audio/raw-file/tip/webaudio/specification.html#AudioGainNode)
	// and a
	// [compressorNode](https://dvcs.w3.org/hg/audio/raw-file/tip/webaudio/specification.html#DynamicsCompressorNode).
	// The gainNode is used to tune the volume. and the compressNode to smooth the peaks we could
	// hit in the sound.
	var webaudio	= new WebAudio();
	
	// Now that we go webaudio available, let's use it to create the sound we gonna play.
	// ```.createSound()``` will create a ```WebAudio.Sound```. Then we ```.load()``` it
	// from this url 'sounds/perfume.mp3'. The callback will be notified as soon as the sound
	// is loaded. Then we simply start to play it. Don't forget to get ```.loop(true)```
	// thus the sound will loop forever.
	var sound	= webaudio.createSound().load('sounds/perfume.mp3', function(sound){
		sound.loop(true).play();
	});

	// # Init the 3D
	
	// First we gonna init our tQuery world.
	var world	= tQuery.createWorld().boilerplate().start();
	
	// the background color is set to ```0x000000```, aka black
	world.renderer().setClearColorHex( 0x000000, 1 );

	// add lights
	tQuery.createDirectionalLight().addTo(world).position(1,1,0.5).color(0xFF88CC).intensity(4);
	tQuery.createDirectionalLight().addTo(world).position(-1,-1,0.2).color(0x4488CC).intensity(4);


	// # Some constants
	
	// build histogram with tquery
	var nBar	= 41;
	// this number MUST be odd
	console.assert(nBar%2)
	var nBarHalf	= Math.ceil(nBar/2)
	// to store the object3D for all bars of the  histogram
	var bars3d	= [];
	// compute the bar width	
	var barW	= 80/nBar;

	// # Create the 3D

	// create the container group3D which gonna regroup all the bar3D
	var group3d	= tQuery.createObject3D().scale(1/20).addTo(world);
	// We gonna build each bar and add it to ```group3d```.
	// We loop to create ```nBar``` with ```tQuery.createCube()```. In fact a bar
	// is a rectangular box, so like a cube with different dimensions.
	// a bar got a width of ```barW```, an height of 10 and a depth of 5.
	// The material is a simple [lambert](http://en.wikipedia.org/wiki/Lambertian_reflection).
	// Once the bar is create, we add it to ```group3d``` and set it to the correct
	// position in space.
	// We push every bar3d into ```bars3d``` for future reference.
	for(var i = 0; i < nBar; i++){
		var bar3d	= tQuery.createCube(barW, 10, 5, new THREE.MeshLambertMaterial({
			ambient	: 0x888888,
			color	: 0xFFFFFF
		}))
		bar3d.addTo(group3d).position((i-nBar/2)*barW, 0, 0);
		bars3d.push(bar3d)
	}
	
	// # Update Vuemeter
	
	// Here we hook a function to tQuery rendering loop, ```tQuery.Loop```. Thus
	// this function gonna be executed everytime our 3D scene is rendered.
	world.loop().hook(function(){
		// if the sound isnt yet loaded, do nothing
		if( sound.isPlayable() === false )	return;
		// build the histogram of the sound based on
		// [RealtimeAnalyserNode](https://dvcs.w3.org/hg/audio/raw-file/tip/webaudio/specification.html#RealtimeAnalyserNode)
		// ```.getByteFrequencyData()```
		var histo	= sound.makeHistogram(nBarHalf);
		// We gonna loop over each bar3D of our vuemeter. We gonna update
		// each of them based on the sound histogram we just computed.
		bars3d.forEach(function(bar3d, barIdx){
			// We need to determine which value in the histogram match this vuemeter bar.
			// As our vuemeter is symetric, the vuemeter bar on the far left got the same
			// histogram value as the one on the far right. This make this computation
			// a bit confusing.
			var histoIdx		= barIdx < nBarHalf ? nBarHalf-1-barIdx : barIdx - nBarHalf;
			// Now we need to compute the height of the vuemeter bar based on histogram value.
			// This is simple scaling from one to the other: vuemeter height === histo height / 256
			var height		= histo[histoIdx] / 256;
			// Now that we computed all that, we update the ```bar3d```. We update ```.scale.y```
			// to change its size and ```.material.color``` to change its color. The formulas
			// i used "worked for me". Up to you to be creative and find the one that fit
			// your own needs
			bar3d.get(0).scale.y	= height*3;
			bar3d.get(0).material.color.setHSV(0.3+height*0.7,1,1)
		});
	})
</script></body>